# -*- coding: utf-8 -*-
"""Untitled10.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/11bWW18LuZKfKAtUrS-SSkL67DTucZ6Q6
"""

# Commented out IPython magic to ensure Python compatibility.
from IPython.core.debugger import set_trace
import pandas as pd
import numpy as np
import os
import matplotlib.pyplot as plt
#plt.style.use('fivethirtyeight')
import time
import math

plt.style.use(style="seaborn")
# %matplotlib inline

import warnings
warnings.filterwarnings('ignore')

from pylab import rcParams
rcParams['figure.figsize'] = 10, 6
from statsmodels.tsa.stattools import adfuller
from statsmodels.tsa.seasonal import seasonal_decompose
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error, mean_absolute_error

from google.colab import drive
drive.mount('/content/drive')

df = pd.read_csv('/content/GOOG_Price.csv')
df

pip install pmdarima

n = int(len(df) * 0.8)
# n_=int(len(df)*0.1)
#n = 1751
train = {}
test = {}
train_index = {}
test_index = {}
train = df['Change'][:n]
test = df['Change'][n:]
train_index = df['Close'][:n]
test_index = df['Close'][n:]
# valid=df.Close[n+n_:len(df)]

from pmdarima.arima import auto_arima

model_autoARIMA = auto_arima(train, start_p=0, start_q=0,
                      test='adf',       # use adftest to find optimal 'd'
                      max_p=5, max_q=5, # maximum p and q
                      m=1,              # frequency of series
                      d=None,           # let model determine 'd'
                      seasonal=False,   # No Seasonality
                      start_P=0,
                      D=0,
                      trace=True,
                      error_action='ignore',
                      suppress_warnings=True,
                      stepwise=True)
print(model_autoARIMA.summary())
#result = model_autoARIMA.fit(method="innovations_mle")
model_autoARIMA.plot_diagnostics(figsize=(15,8))
plt.show()

from statsmodels.tsa.arima.model import ARIMA
model=ARIMA(train,order=(1,0,0))
model=model.fit(method="innovations_mle")
model.summary()

# Actual vs Fitted
print(df[0:20], "\n\n")
predict = model.predict(start=1, end=1400, dynamic=False)
plt.plot(df["Change"][:1400], label=f"Return")
plt.plot(predict, label=f"forecast Return")

plt.legend(loc="upper left")

step = len(test)
model = ARIMA(train, order=(1,0,0))
result = model.fit(method="innovations_mle")
# Forecast
fc = result.forecast(steps=step)
print(fc)

model = ARIMA(train, order=(1,0,0))
fitted = model.fit(method='innovations_mle')

fc = fitted.forecast(302, alpha=0.05)  # 95% conf

# Make as pandas series
fc_series = pd.Series(fc, index=test[:302].index)
# lower_series = pd.Series(conf[:, 0], index=test[:10].index)
# upper_series = pd.Series(conf[:, 1], index=test[:10].index)


for i in range(1208, 1510):
        fc_series[i] = (10**fc[i])*df["Close"][i]
        print(fc_series[i])

# Plot
plt.figure(figsize=(24, 8), dpi=100)
plt.plot(train_index, label=f"training Vn-Index")
plt.plot(test_index, label=f"actual Vn-Index")
plt.plot(fc_series, label=f"forecast Vn-Index")
# plt.fill_between(lower_series.index, lower_series, upper_series, color="k", alpha=0.15)
plt.title(f"Forecast vs Actuals")
plt.legend(loc="upper left", fontsize=8)
plt.show()